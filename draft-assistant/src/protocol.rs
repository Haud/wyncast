// Message protocol types for WebSocket communication and internal async channels.

use serde::{Deserialize, Serialize};

use crate::draft::pick::DraftPick;
use crate::draft::roster::RosterSlot;
use crate::valuation::scarcity::ScarcityEntry;
use crate::valuation::zscore::PlayerValuation;

// ---------------------------------------------------------------------------
// Extension -> Backend messages (JSON over WebSocket)
// ---------------------------------------------------------------------------

/// Messages received from the Firefox extension over WebSocket.
/// Serialized/deserialized as internally-tagged JSON using the `type` field.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
pub enum ExtensionMessage {
    /// Sent once when the extension first connects.
    #[serde(rename = "EXTENSION_CONNECTED")]
    ExtensionConnected { payload: ExtensionConnectedPayload },

    /// Periodic draft-state snapshot pushed by the extension.
    #[serde(rename = "STATE_UPDATE")]
    StateUpdate {
        timestamp: u64,
        payload: StateUpdatePayload,
    },

    /// Keep-alive heartbeat from the extension.
    #[serde(rename = "EXTENSION_HEARTBEAT")]
    ExtensionHeartbeat { payload: HeartbeatPayload },
}

// ---------------------------------------------------------------------------
// Payload structs (camelCase JSON <-> snake_case Rust)
// ---------------------------------------------------------------------------

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct ExtensionConnectedPayload {
    pub platform: String,
    pub extension_version: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct StateUpdatePayload {
    pub picks: Vec<PickData>,
    #[serde(default)]
    pub current_nomination: Option<NominationData>,
    pub my_team_id: Option<String>,
    #[serde(default)]
    pub teams: Vec<TeamBudgetData>,
    /// Current pick number from the ESPN clock label (e.g. "PK 128 OF 260").
    #[serde(default)]
    pub pick_count: Option<u32>,
    /// Total number of picks from the ESPN clock label.
    #[serde(default)]
    pub total_picks: Option<u32>,
    pub source: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct PickData {
    pub pick_number: u32,
    pub team_id: String,
    pub team_name: String,
    pub player_id: String,
    pub player_name: String,
    pub position: String,
    pub price: u32,
    #[serde(default)]
    pub eligible_slots: Vec<u16>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct NominationData {
    pub player_id: String,
    pub player_name: String,
    pub position: String,
    pub nominated_by: String,
    pub current_bid: u32,
    pub current_bidder: Option<String>,
    pub time_remaining: Option<u32>,
    #[serde(default)]
    pub eligible_slots: Vec<u16>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct TeamBudgetData {
    /// ESPN team ID extracted from the pick train (e.g. "1", "2").
    /// Optional for backward compatibility with older extension messages.
    #[serde(default)]
    pub team_id: Option<String>,
    pub team_name: String,
    pub budget: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct HeartbeatPayload {
    pub timestamp: u64,
}

// ---------------------------------------------------------------------------
// Internal connection events (not serialized to/from JSON)
// ---------------------------------------------------------------------------

/// Events generated by the WebSocket server for connection lifecycle.
#[derive(Debug, Clone, PartialEq)]
pub enum InternalEvent {
    /// A new extension client connected from the given address.
    Connected { addr: String },
    /// The extension client disconnected.
    Disconnected,
}

// ---------------------------------------------------------------------------
// Internal app messages (for mpsc channels, no serde needed)
// ---------------------------------------------------------------------------

/// Events produced by the LLM streaming client.
#[derive(Debug, Clone, PartialEq)]
pub enum LlmEvent {
    /// A single token of streamed output.
    Token(String),
    /// The LLM response is complete.
    Complete {
        full_text: String,
        input_tokens: u32,
        output_tokens: u32,
    },
    /// An error occurred during LLM interaction.
    Error(String),
}

/// Commands sent from the TUI to the app orchestrator.
#[derive(Debug, Clone, PartialEq)]
pub enum UserCommand {
    RefreshAnalysis,
    RefreshPlan,
    ManualPick {
        player_name: String,
        team_idx: usize,
        price: u32,
    },
    SwitchTab(TabId),
    Scroll {
        widget: WidgetId,
        direction: ScrollDirection,
    },
    Quit,
}

/// Updates pushed from the app orchestrator to the TUI render loop.
#[derive(Debug, Clone)]
pub enum UiUpdate {
    /// Full state snapshot for a complete redraw.
    StateSnapshot(Box<AppSnapshot>),
    /// A new token for the analysis panel.
    AnalysisToken(String),
    /// Analysis streaming is complete.
    AnalysisComplete,
    /// A new token for the nomination plan panel.
    PlanToken(String),
    /// Nomination plan streaming is complete.
    PlanComplete,
    /// Extension connection status changed.
    ConnectionStatus(ConnectionStatus),
    /// A new nomination is active.
    NominationUpdate(Box<NominationInfo>),
    /// Bid updated on the current nomination (same player, new bid amount).
    /// Unlike NominationUpdate, this does NOT clear accumulated LLM text.
    BidUpdate(Box<NominationInfo>),
    /// The current nomination was cleared (pick completed).
    NominationCleared,
}

/// WebSocket connection status.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConnectionStatus {
    Connected,
    Disconnected,
}

/// LLM streaming status.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LlmStatus {
    Idle,
    Streaming,
    Complete,
    Error,
}

/// Tab identifiers for the TUI layout.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TabId {
    Analysis,
    NomPlan,
    Available,
    DraftLog,
    Teams,
}

/// Widget identifiers for scroll targeting.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WidgetId {
    MainPanel,
    Roster,
    Scarcity,
}

/// Scroll direction commands.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ScrollDirection {
    Up,
    Down,
    PageUp,
    PageDown,
}

// ---------------------------------------------------------------------------
// Placeholder structs (filled in by later tasks)
// ---------------------------------------------------------------------------

/// Snapshot of the full application state, sent to the TUI for rendering.
///
/// Carries all recalculated data after picks are processed so the TUI
/// can update its ViewState in one shot.
#[derive(Debug, Clone)]
pub struct AppSnapshot {
    pub pick_count: usize,
    pub total_picks: usize,
    pub active_tab: Option<TabId>,
    /// Remaining player pool with updated valuations.
    pub available_players: Vec<PlayerValuation>,
    /// Recomputed positional scarcity indices.
    pub positional_scarcity: Vec<ScarcityEntry>,
    /// Chronological list of completed draft picks.
    pub draft_log: Vec<DraftPick>,
    /// User's roster slots (position + optional player).
    pub my_roster: Vec<RosterSlot>,
    /// Budget fields for the user's team.
    pub budget_spent: u32,
    pub budget_remaining: u32,
    pub salary_cap: u32,
    /// Current league-wide inflation rate.
    pub inflation_rate: f64,
    /// Maximum bid the user can make right now.
    pub max_bid: u32,
    /// Average dollars remaining per empty roster slot.
    pub avg_per_slot: f64,
    /// Per-team summaries (name, budget, slots filled/total).
    pub team_snapshots: Vec<TeamSnapshot>,
}

/// Lightweight summary of a team's draft state for the snapshot.
#[derive(Debug, Clone)]
pub struct TeamSnapshot {
    pub name: String,
    pub budget_remaining: u32,
    pub slots_filled: usize,
    pub total_slots: usize,
}

/// Info about the current active nomination.
#[derive(Debug, Clone, PartialEq)]
pub struct NominationInfo {
    pub player_name: String,
    pub position: String,
    pub nominated_by: String,
    pub current_bid: u32,
    pub current_bidder: Option<String>,
    pub time_remaining: Option<u32>,
    pub eligible_slots: Vec<u16>,
}

/// Instant analysis result for a nominated player.
#[derive(Debug, Clone, PartialEq)]
pub struct InstantAnalysis {
    pub player_name: String,
    pub dollar_value: f64,
    pub adjusted_value: f64,
    pub verdict: InstantVerdict,
}

/// Quick verdict for a nomination.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum InstantVerdict {
    StrongTarget,
    ConditionalTarget,
    Pass,
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    // -- JSON round-trip for all ExtensionMessage variants --

    #[test]
    fn round_trip_extension_connected() {
        let msg = ExtensionMessage::ExtensionConnected {
            payload: ExtensionConnectedPayload {
                platform: "firefox".to_string(),
                extension_version: "1.0.0".to_string(),
            },
        };
        let json = serde_json::to_string(&msg).unwrap();
        let parsed: ExtensionMessage = serde_json::from_str(&json).unwrap();
        assert_eq!(msg, parsed);
    }

    #[test]
    fn round_trip_state_update() {
        let msg = ExtensionMessage::StateUpdate {
            timestamp: 1700000000,
            payload: StateUpdatePayload {
                picks: vec![PickData {
                    pick_number: 1,
                    team_id: "team_3".to_string(),
                    team_name: "Vorticists".to_string(),
                    player_id: "12345".to_string(),
                    player_name: "Shohei Ohtani".to_string(),
                    position: "DH".to_string(),
                    price: 62,
                    eligible_slots: vec![11, 12, 16, 17],
                }],
                current_nomination: Some(NominationData {
                    player_id: "67890".to_string(),
                    player_name: "Aaron Judge".to_string(),
                    position: "OF".to_string(),
                    nominated_by: "Team Alpha".to_string(),
                    current_bid: 55,
                    current_bidder: Some("Team Beta".to_string()),
                    time_remaining: Some(15),
                    eligible_slots: vec![5, 8, 9, 10, 11, 12, 16, 17],
                }),
                my_team_id: Some("team_7".to_string()),
                teams: vec![TeamBudgetData {
                    team_id: Some("3".to_string()),
                    team_name: "Vorticists".to_string(),
                    budget: 198,
                }],
                pick_count: None,
                total_picks: None,
                source: Some("dom_scraper".to_string()),
            },
        };
        let json = serde_json::to_string(&msg).unwrap();
        let parsed: ExtensionMessage = serde_json::from_str(&json).unwrap();
        assert_eq!(msg, parsed);
    }

    #[test]
    fn round_trip_heartbeat() {
        let msg = ExtensionMessage::ExtensionHeartbeat {
            payload: HeartbeatPayload {
                timestamp: 1700000001,
            },
        };
        let json = serde_json::to_string(&msg).unwrap();
        let parsed: ExtensionMessage = serde_json::from_str(&json).unwrap();
        assert_eq!(msg, parsed);
    }

    // -- Deserialize from hand-written JSON (camelCase -> snake_case) --

    #[test]
    fn deserialize_extension_connected_camel_case() {
        let json = r#"{
            "type": "EXTENSION_CONNECTED",
            "payload": {
                "platform": "firefox",
                "extensionVersion": "0.2.1"
            }
        }"#;
        let msg: ExtensionMessage = serde_json::from_str(json).unwrap();
        match msg {
            ExtensionMessage::ExtensionConnected { payload } => {
                assert_eq!(payload.platform, "firefox");
                assert_eq!(payload.extension_version, "0.2.1");
            }
            _ => panic!("expected ExtensionConnected variant"),
        }
    }

    #[test]
    fn deserialize_heartbeat_camel_case() {
        let json = r#"{
            "type": "EXTENSION_HEARTBEAT",
            "payload": {
                "timestamp": 9999
            }
        }"#;
        let msg: ExtensionMessage = serde_json::from_str(json).unwrap();
        match msg {
            ExtensionMessage::ExtensionHeartbeat { payload } => {
                assert_eq!(payload.timestamp, 9999);
            }
            _ => panic!("expected ExtensionHeartbeat variant"),
        }
    }

    #[test]
    fn deserialize_state_update_with_picks_and_nomination() {
        let json = r#"{
            "type": "STATE_UPDATE",
            "timestamp": 1700000005,
            "payload": {
                "picks": [
                    {
                        "pickNumber": 1,
                        "teamId": "team_3",
                        "teamName": "Vorticists",
                        "playerId": "12345",
                        "playerName": "Shohei Ohtani",
                        "position": "DH",
                        "price": 62
                    },
                    {
                        "pickNumber": 2,
                        "teamId": "team_5",
                        "teamName": "Sluggers",
                        "playerId": "54321",
                        "playerName": "Mookie Betts",
                        "position": "SS",
                        "price": 48
                    }
                ],
                "currentNomination": {
                    "playerId": "67890",
                    "playerName": "Aaron Judge",
                    "position": "OF",
                    "nominatedBy": "Team Alpha",
                    "currentBid": 55,
                    "currentBidder": "Team Beta",
                    "timeRemaining": 15
                },
                "myTeamId": "team_7",
                "source": "dom_scraper"
            }
        }"#;
        let msg: ExtensionMessage = serde_json::from_str(json).unwrap();
        match msg {
            ExtensionMessage::StateUpdate { timestamp, payload } => {
                assert_eq!(timestamp, 1700000005);
                assert_eq!(payload.picks.len(), 2);
                assert_eq!(payload.picks[0].pick_number, 1);
                assert_eq!(payload.picks[0].player_name, "Shohei Ohtani");
                assert_eq!(payload.picks[1].pick_number, 2);
                assert_eq!(payload.picks[1].player_name, "Mookie Betts");
                let nom = payload.current_nomination.unwrap();
                assert_eq!(nom.player_name, "Aaron Judge");
                assert_eq!(nom.current_bid, 55);
                assert_eq!(nom.time_remaining, Some(15));
                assert_eq!(payload.my_team_id, Some("team_7".to_string()));
                assert_eq!(payload.source, Some("dom_scraper".to_string()));
            }
            _ => panic!("expected StateUpdate variant"),
        }
    }

    #[test]
    fn deserialize_state_update_no_nomination() {
        let json = r#"{
            "type": "STATE_UPDATE",
            "timestamp": 1700000010,
            "payload": {
                "picks": [],
                "currentNomination": null,
                "myTeamId": "team_1",
                "source": "react_state"
            }
        }"#;
        let msg: ExtensionMessage = serde_json::from_str(json).unwrap();
        match msg {
            ExtensionMessage::StateUpdate { payload, .. } => {
                assert!(payload.picks.is_empty());
                assert!(payload.current_nomination.is_none());
            }
            _ => panic!("expected StateUpdate variant"),
        }
    }

    #[test]
    fn deserialize_state_update_omitted_nomination() {
        // With #[serde(default)], omitting currentNomination entirely should work
        let json = r#"{
            "type": "STATE_UPDATE",
            "timestamp": 1700000010,
            "payload": {
                "picks": [],
                "myTeamId": "team_1",
                "source": "react_state"
            }
        }"#;
        let msg: ExtensionMessage = serde_json::from_str(json).unwrap();
        match msg {
            ExtensionMessage::StateUpdate { payload, .. } => {
                assert!(payload.current_nomination.is_none());
            }
            _ => panic!("expected StateUpdate variant"),
        }
    }

    // -- Malformed JSON returns error (does not panic) --

    #[test]
    fn malformed_json_returns_error() {
        let bad_json = r#"{ this is not valid json }"#;
        let result = serde_json::from_str::<ExtensionMessage>(bad_json);
        assert!(result.is_err());
    }

    #[test]
    fn missing_type_field_returns_error() {
        let json = r#"{ "payload": { "timestamp": 123 } }"#;
        let result = serde_json::from_str::<ExtensionMessage>(json);
        assert!(result.is_err());
    }

    #[test]
    fn unknown_type_variant_returns_error() {
        let json = r#"{ "type": "UNKNOWN_TYPE", "payload": {} }"#;
        let result = serde_json::from_str::<ExtensionMessage>(json);
        assert!(result.is_err());
    }

    #[test]
    fn missing_required_payload_field_returns_error() {
        // Missing extensionVersion in EXTENSION_CONNECTED payload
        let json = r#"{
            "type": "EXTENSION_CONNECTED",
            "payload": {
                "platform": "firefox"
            }
        }"#;
        let result = serde_json::from_str::<ExtensionMessage>(json);
        assert!(result.is_err());
    }

    // -- camelCase serialization check --

    #[test]
    fn serialized_json_uses_camel_case() {
        let msg = ExtensionMessage::StateUpdate {
            timestamp: 100,
            payload: StateUpdatePayload {
                picks: vec![PickData {
                    pick_number: 1,
                    team_id: "team_2".to_string(),
                    team_name: "Test".to_string(),
                    player_id: "p3".to_string(),
                    player_name: "Player".to_string(),
                    position: "C".to_string(),
                    price: 10,
                    eligible_slots: vec![],
                }],
                current_nomination: None,
                my_team_id: Some("team_5".to_string()),
                teams: vec![],
                pick_count: None,
                total_picks: None,
                source: Some("test".to_string()),
            },
        };
        let json = serde_json::to_string(&msg).unwrap();
        // Verify camelCase keys are present
        assert!(json.contains("pickNumber"));
        assert!(json.contains("teamId"));
        assert!(json.contains("teamName"));
        assert!(json.contains("playerId"));
        assert!(json.contains("playerName"));
        assert!(json.contains("currentNomination"));
        assert!(json.contains("myTeamId"));
        assert!(json.contains("eligibleSlots"));
        // Verify snake_case keys are NOT present
        assert!(!json.contains("pick_number"));
        assert!(!json.contains("player_name"));
        assert!(!json.contains("eligible_slots"));
    }

    // -- AppSnapshot construction --

    #[test]
    fn app_snapshot_construction() {
        let snap = AppSnapshot {
            pick_count: 0,
            total_picks: 0,
            active_tab: None,
            available_players: vec![],
            positional_scarcity: vec![],
            draft_log: vec![],
            my_roster: vec![],
            budget_spent: 0,
            budget_remaining: 260,
            salary_cap: 260,
            inflation_rate: 1.0,
            max_bid: 0,
            avg_per_slot: 0.0,
            team_snapshots: vec![],
        };
        assert_eq!(snap.pick_count, 0);
        assert_eq!(snap.total_picks, 0);
        assert_eq!(snap.active_tab, None);
        assert!(snap.available_players.is_empty());
        assert!(snap.team_snapshots.is_empty());
    }

    // -- eligible_slots backward compatibility --

    #[test]
    fn eligible_slots_defaults_to_empty_when_omitted() {
        // JSON without eligibleSlots fields should still deserialize
        // thanks to #[serde(default)]
        let json = r#"{
            "type": "STATE_UPDATE",
            "timestamp": 1700000000,
            "payload": {
                "picks": [
                    {
                        "pickNumber": 1,
                        "teamId": "team_1",
                        "teamName": "Team 1",
                        "playerId": "p1",
                        "playerName": "Player One",
                        "position": "SP",
                        "price": 30
                    }
                ],
                "currentNomination": {
                    "playerId": "p2",
                    "playerName": "Player Two",
                    "position": "1B",
                    "nominatedBy": "Team 2",
                    "currentBid": 5,
                    "currentBidder": null,
                    "timeRemaining": 30
                },
                "myTeamId": "team_1",
                "source": "test"
            }
        }"#;
        let msg: ExtensionMessage = serde_json::from_str(json).unwrap();
        match msg {
            ExtensionMessage::StateUpdate { payload, .. } => {
                assert!(payload.picks[0].eligible_slots.is_empty());
                let nom = payload.current_nomination.unwrap();
                assert!(nom.eligible_slots.is_empty());
            }
            _ => panic!("expected StateUpdate variant"),
        }
    }

    #[test]
    fn eligible_slots_round_trip_with_values() {
        let pick_data = PickData {
            pick_number: 1,
            team_id: "team_1".into(),
            team_name: "Team 1".into(),
            player_id: "p1".into(),
            player_name: "Mookie Betts".into(),
            position: "SS".into(),
            price: 40,
            eligible_slots: vec![4, 2, 5, 8, 9, 10, 11, 12, 16, 17],
        };
        let json = serde_json::to_string(&pick_data).unwrap();
        let parsed: PickData = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.eligible_slots, vec![4, 2, 5, 8, 9, 10, 11, 12, 16, 17]);
    }
}
